#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{xcolor}
\usepackage{sectsty}

\definecolor{cerulean}{HTML}{2A52BE}
\definecolor{processblue}{HTML}{0085CA}
\definecolor{greengreen}{HTML}{008000}

\chapterfont{\color{blue}}  % sets colour of chapters
\sectionfont{\color{cyan}}  % sets colour of sections
\subsectionfont{\color{processblue}}  % sets colour of subsections
\subsubsectionfont{\color{cerulean}}  % sets colour of subsubsections
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_title "Chapter 9 - Pointers"
\pdf_author "Joshua Saunders"
\pdf_subject "C++ pointers"
\pdf_keywords "c++, pointers"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 2
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 0.75in
\rightmargin 0.75in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily},commentstyle={\color{green}\ttfamily},keywordstyle={\color{blue}\ttfamily},morecomment={[l][\color{magenta}]{\#}},stringstyle={\color{red}\ttfamily},showstringspaces=false,language={C++},commentstyle={\color{greengreen}\ttfamily},frame=tbl,numbers=left"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Pointers
\end_layout

\begin_layout Section
Getting the Address of a Variable
\end_layout

\begin_layout Standard
Every variable of a computer program is allotted a section of memory that's
 large enough for the variable's data type.
 See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:memory-allocated-for-some-data-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below for the memory allocated for some common data types.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Memory allocated for some common data types
\begin_inset CommandInset label
LatexCommand label
name "tab:memory-allocated-for-some-data-types"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory allocated (bytes)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To get the address of a variable, the address (&) operator is used.
 This is not to be confused with & which is used when defining a reference
 variable.
 See Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "address-operator-ex-program"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below for an example.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/addressOfOperator.cpp"
lstparams "language={C++},caption={A simple program that shows how to use the address operator},label={address-operator-ex-program}"

\end_inset


\end_layout

\begin_layout Section
Pointer Variables
\end_layout

\begin_layout Standard
A 
\emph on
pointer variable
\emph default
, or just 
\emph on
pointer
\emph default
, is a variable that holds a memory address which can be used to hold the
 location of some other piece of data.
 This allows you to indirectly manipulate data stored in other variables.
 It's similar to working with functions that have parameters that are passed
 by reference.
 However, with reference variables C++ automatically handles storing the
 data into the referenced variable while pointers operate at a lower level
 and as the programmer you must write the code that assigns the fetches
 the memory address and assigns the value of the address to a pointer variable.
 Another caveat of working with pointers is that you must specify that you
 want to store the data at the memory location referenced by the pointer
 versus in the pointer itself.
\end_layout

\begin_layout Standard
Even though working with pointers seems like more work than using reference
 variables, it is sometimes the only way to accomplish useful operations
 such as dynamic memory allocation for example.
 They also allow you to create variables, arrays, and complex data structures
 in memory while a program is running.
\end_layout

\begin_layout Subsection
Creating and Using Pointer Variables
\end_layout

\begin_layout Standard
Pointer variables, or pointers, can be defined in one of two ways, as shown
 below in Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-initialization"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The first pointer, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pointer1
\end_layout

\end_inset

, looks like any standard variable initialization except for the preceding
 asterisk.
 The second pointer, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pointer2
\end_layout

\end_inset

, has the asterisk attached to the 
\begin_inset listings
lstparams "language={C++}"
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset

 which visually reinforces that this variable is 
\series bold
not
\series default
 an integer, but rather a 
\emph on
pointer to
\emph default
 an integer.
 Both declarations are equivalent however.
 Note that even though both declarations have the 
\begin_inset listings
lstparams "language={C++}"
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset

 keyword 
\series bold
they are not 
\series default

\begin_inset listings
lstparams "language={C++}"
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset


\series bold
s
\series default
! Rather, they are pointers to 
\begin_inset listings
lstparams "language={C++}"
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset

 type variables.
 This distinction is subtle yet important.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerInitialization.cpp"
lstparams "language={C++},numbers=none,caption={Two ways to initialize pointer variables},label={pointer-initialization}"

\end_inset


\end_layout

\begin_layout Standard
One thing that Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-initialization"
plural "false"
caps "false"
noprefix "false"

\end_inset

 does not show is 
\emph on
good
\emph default
 pointer declaration.
 Pointers should be initialized when declared either to the address of an
 actual variable or to the 
\begin_inset listings
lstparams "language={C++}"
inline true
status open

\begin_layout Plain Layout

nullptr
\end_layout

\end_inset

 special keyword.
 The reason being that if a pointer is not initialized then you could be
 affecting an unknown location in memory.
 Pointers can also be initialized to 
\family typewriter
0
\family default
 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NULL
\end_layout

\end_inset

 if you're using an older compiler that doesn't support C++11 or newer.
 Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "store-print-addresses-with-pointers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below shows how to store and print addresses using pointers and below that
 is the result of the program.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/storePrintAddressesWithPointers.cpp"
lstparams "language={C++},caption={Storing and printing values and addresses with pointers},label={store-print-addresses-with-pointers}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

The value in x is 25
\end_layout

\begin_layout Plain Layout

The address of x is 0xffffcc0c
\end_layout

\begin_layout Plain Layout

The address of nullPtr is 0 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So far, we've only seen how to use pointers to get the address off a variable.
 Let's see how to use the data at the address using the indirection operator
 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

).
 When placed in front of a pointer, the indirection operator 
\emph on
dereferences
\emph default
 the pointer allowing you to work with the data that the pointer is pointing
 to.
 Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "indirection-operator"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how this works with the output immediately below.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/indirectionOperator.cpp"
lstparams "language={C++},caption={How the indirection operator works},label={indirection-operator}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Here is the value in x, printed twice:
\end_layout

\begin_layout Plain Layout

25
\end_layout

\begin_layout Plain Layout

25
\end_layout

\begin_layout Plain Layout

Once again, here is the value in x:
\end_layout

\begin_layout Plain Layout

100
\end_layout

\begin_layout Plain Layout

100 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-multi-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows a more complex usage of pointers in which one pointer references
 different variables and we manipulate those data using the pointer.
 The output is immediately below.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerMultiVars.cpp"
lstparams "language={C++},caption={Referencing different variables with one pointer},label={pointer-multi-variables}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Here are the values of x, y, and z:
\end_layout

\begin_layout Plain Layout

25 50 75
\end_layout

\begin_layout Plain Layout

Once again, here are the values of x, y, and z:
\end_layout

\begin_layout Plain Layout

125 150 175
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Relationship Between Arrays and Pointers
\end_layout

\begin_layout Standard
An array name without brackets and a subscript represents the starting address
 of an array which means that 
\emph on
the name is really a pointer
\emph default
.
 This can be demonstrated by a simple program, shown in Program Listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "array-name-as-pointer"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and its output below.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/arrayNameAsPointer.cpp"
lstparams "language={C++},caption={Using an array name as a pointer},label={array-name-as-pointer}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

The first element of the array is 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's possible to access the elements of an array using the array's name
 as the starting address, or the first element of the array.
 In addition to using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

numbers[1]
\end_layout

\end_inset

 to access the second element of the array we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*(numbers + 1)
\end_layout

\end_inset

, which is called 
\emph on
pointer notation
\emph default
.
 To access the 
\family typewriter
n - 1
\family default
 element of the array, you would use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*(numbers + n - 1)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n - 1
\end_layout

\end_inset

 is the 
\emph on
size of the data type
\emph default
 that the array is holding (which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

short
\end_layout

\end_inset

 in this case) and the subscript.
 This is an important distinction that you must take care to remember.
 In other words, you can add the subscript to the name inside of the dereferenci
ng operator access a particular element (don't forget the parentheses!).
 Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "process-array-using-pointer-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 demonstrates how to process an array using pointer notation.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/processArrayUsingPointerNotation.cpp"
lstparams "language={C++},caption={Processing an array using pointer notation},label={process-array-using-pointer-notation}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Enter 5 numbers: 5 10 20 40 80
\end_layout

\begin_layout Plain Layout

Here are the numbers you entered:
\end_layout

\begin_layout Plain Layout

5 10 20 40 80 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Surprisingly (or perhaps not), you can use subscripts with pointers and
 pointer notation with arrays! Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-subscripts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below shows a program that does just that with the output of the program
 below.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerSubscripts.cpp"
lstparams "language={C++},caption={Processing an array using pointer notation},label={pointer-subscripts}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Here are the values in the coins array:
\end_layout

\begin_layout Plain Layout

0.5 0.1 0.25 0.5 1
\end_layout

\begin_layout Plain Layout

And here they are again:
\end_layout

\begin_layout Plain Layout

0.5 0.1 0.25 0.5 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the address operator doesn't need to be used to get the address
 of an array.
 It can, however, be used to get the address of the elements of an array.
 Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "array-element-addresses"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below shows a program that does just that with the output of the program
 below.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/arrayElementAddresses.cpp"
lstparams "language={C++},caption={Using a pointer to display data in an array},label={array-element-addresses}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Here are the values in the coins array:
\end_layout

\begin_layout Plain Layout

0.05 0.1 0.25 0.5 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Keep in mind that there is one difference between pointers and arrays: the
 address an array name points to 
\emph on
cannot be changed
\emph default
 (they're 
\emph on
pointer constants
\emph default
).
\end_layout

\begin_layout Section
Pointer Arithmetic
\end_layout

\begin_layout Standard
The contents of a pointer variable can be manipulated using addition and
 subtraction.
 For instance, Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-increment-and-decrement"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how a pointer of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset

 is incremented and decremented and is used to display the contents of an
 array.
 When incrementing or decrementing a pointer, the s
\emph on
ize of the type that pointer is pointing to
\emph default
 is added to the pointer.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerIncrementDecrement.cpp"
lstparams "language={C++},caption={Incrementing and decrementing a pointer},label={pointer-increment-and-decrement}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

The numbers in the set are:
\end_layout

\begin_layout Plain Layout

5 10 15 20 25 30 35 40
\end_layout

\begin_layout Plain Layout

The numbers in the set backward are:
\end_layout

\begin_layout Plain Layout

40 35 30 25 20 15 10 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With pointers, we can
\end_layout

\begin_layout Itemize
use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

++
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

--
\end_layout

\end_inset

 operators to increment and decrement
\end_layout

\begin_layout Itemize
add or subtract integers to and from a pointer using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+=
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-=
\end_layout

\end_inset

 operators
\end_layout

\begin_layout Itemize
subtract one pointer from another
\end_layout

\begin_layout Section
Initializing Pointers
\end_layout

\begin_layout Standard
Pointers point to a specific data type and must therefore only be used with
 that data type type.
 Below are lists of examples of legal and illegal pointer initializations.
\end_layout

\begin_layout Subsection*
Legal Pointer Initializations
\end_layout

\begin_layout Standard
Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "legal-pointer-initializations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 gives examples of legal initializations of pointers.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/legalPointerInits.cpp"
lstparams "language={C++},caption={Legal pointer initializations},label={legal-pointer-initializations}"

\end_inset


\end_layout

\begin_layout Subsection*
Illegal Pointer Initializations
\end_layout

\begin_layout Standard
Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "illegal-pointer-initializations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 gives examples of illegal initializations of pointers.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/legalPointerInits.cpp"
lstparams "language={C++},caption={Illegal pointer initializations},label={illegal-pointer-initializations}"

\end_inset


\end_layout

\begin_layout Section
Comparing Pointers
\end_layout

\begin_layout Standard
Pointers can be compared using C++'s relational operators (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!=
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<=
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>=
\end_layout

\end_inset

).
 Elements in arrays are stored in consecutive order in memory which means
 that the address of the first element is less than address of the second
 element.
 You can use this to make sure that you don't step out of the bounds of
 an array.
 Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-comparison"
plural "false"
caps "false"
noprefix "false"

\end_inset

 initializes a pointer to the start of an array then proceeds to step through
 each element forwards until it reaches the address of the last element
 and then backwards until it reaches the address of the first element.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerComparison.cpp"
lstparams "language={C++},caption={Comparing pointers},label={pointer-comparison}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

The numbers in set are:
\end_layout

\begin_layout Plain Layout

5 10 15 20 25 30 35 40
\end_layout

\begin_layout Plain Layout

The numbers in set backward are:
\end_layout

\begin_layout Plain Layout

40 35 30 25 20 15 10 5
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pointers as Function Parameters
\end_layout

\begin_layout Standard
Pointers can be used as function parameters which gives the function access
 to the original argument, similar to reference parameters.
 An example of a function that uses a pointer parameter and how to call
 it is given below in Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-function-parameter-simple"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerFunctionParamSimple.cpp"
lstparams "language={C++},caption={A function with a pointer as a parameter and how to call it},label={pointer-function-parameter-simple}"

\end_inset


\end_layout

\begin_layout Standard
A more complete example is given in Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-function-parameter-complex"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerFunctionParamComplex.cpp"
lstparams "language={C++},caption={A function with a pointer as a parameter and how to call it},label={pointer-function-parameter-complex}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Enter an integer number: 37
\end_layout

\begin_layout Plain Layout

That value doubled is 74
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pointers may be used as a parameter to accept the address of an array.
 Program Listing BLAH below demonstrates this.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerFunctionParamArrayAddress.cpp"
lstparams "language={C++},caption={Pointer function parameter that accepts the address of an array},label={pointer-function-parameter-rarray}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

Enter the sales figure for quarter 1: 10263.98
\end_layout

\begin_layout Plain Layout

Enter the sales figure for quarter 2: 12369.69
\end_layout

\begin_layout Plain Layout

Enter the sales figure for quarter 3: 11542.13
\end_layout

\begin_layout Plain Layout

Enter the sales figure for quarter 4: 14792.06
\end_layout

\begin_layout Plain Layout

The total sales for the year are $48967.86
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-function-parameter-rarray"
plural "false"
caps "false"
noprefix "false"

\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

sum += *arr;
\end_layout

\begin_layout Plain Layout

arr++;
\end_layout

\end_inset

could have been shortened to
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

sum += *arr++;
\end_layout

\end_inset

.
 This is, in my opinion, harder to read because it requires me to correctly
 apply the precedence of each operator involved in that compound statement.
 First, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arr
\end_layout

\end_inset

 is dereferenced, then the value pointed to by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arr
\end_layout

\end_inset

 is added to the current value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and finally 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arr
\end_layout

\end_inset

 is incremented.
 The surface area for failure of understanding is too large for my tastes.
 Simpler is better.
\end_layout

\begin_layout Subsection*
Pointers to Constants
\end_layout

\begin_layout Standard
Sometimes it's necessary to pass a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

's address into a pointer.
 In order to do this, the pointer must also be declared as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 as well.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pointer-to-a-constant"
plural "false"
caps "false"
noprefix "false"

\end_inset

 explains how the semantics of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 pointer as function parameter works.
 In the figure below, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 is applied to what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rates
\end_layout

\end_inset

 points to 
\emph on
not
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rates
\end_layout

\end_inset

 itself.
 Therefore, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rates
\end_layout

\end_inset

 can be changed (i.e., be made to point to something else) while what it points
 to cannot.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename constPointerFuncParam.PNG
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Explanation of pointer to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:pointer-to-a-constant"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Something of interest is that nonconstant arguments can be passed to a function
 in which a parameter was declared as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

.
 This prevents the argument from accidentally being changed.
 This means that it's a good idea to declare the parameter as a pointer
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

.
 See Program Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "pointer-const-parameter"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for an example.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "examples/chapter09/pointerFunctionConstParam.cpp"
lstparams "language={C++},caption={Pointer function parameter that accepts the address of an array},label={pointer-const-parameter}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

1 2 3 4 5 6
\end_layout

\begin_layout Plain Layout

2 4 6 8 10 12
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This behavior has some good, practical use.
 If you are writing a function that takes a pointer as a parameter and the
 function doesn't modify the contents that pointer is pointing to then declare
 the pointer parameter as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 that way you are guaranteed to not inadvertently modify the data.
\end_layout

\begin_layout Subsection*
Constant Pointers
\end_layout

\begin_layout Standard
Not only can we create pointers to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

, we can also declare pointers to be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 as well.
 In this case, we cannot change what the pointer is pointing to.
 The difference between a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 pointer and a pointer to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
pointer to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

: the data that the pointer points to cannot change, but the pointer itself
 can
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 pointer: the pointer itself cannot be changed.
 Once the pointer is initialized with an address, it can't point to anything
 else.
 The data that it points to, however, 
\emph on
can
\emph default
 change
\end_layout

\begin_layout Standard
Here's how to declare a constant pointer
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

int value = 22;
\end_layout

\begin_layout Plain Layout

int * const ptr = &value;
\end_layout

\end_inset

Notice how the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 comes 
\emph on
after
\emph default
 the 
\family typewriter
*
\family default
.
 If any attempt is made to change what address the pointer points to a compiler
 error will result.
 However, no error will happen if we attempt to change the data that's at
 the address.
 This because the pointer itself is constant, the data that it points to
 isn't.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:constant-pointer"
plural "false"
caps "false"
noprefix "false"

\end_inset

 explains the semantics of declaring a constant pointer.
 Remember that because a constant pointer cannot be changed, it must be
 initialized with an initial value.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename constPointer.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Explanation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 pointer
\begin_inset CommandInset label
LatexCommand label
name "fig:constant-pointer"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Constant Pointers to Constants
\end_layout

\begin_layout Standard
It's also possible to have constant pointers that point to constants.
 See the example below and Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:constant-pointer-to-a-constant"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for an example and an explanation of the semantics, respectively.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

int const value = 22;
\end_layout

\begin_layout Plain Layout

int * const ptr = &value;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename constPointerToConst.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Explanation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 pointer
\begin_inset CommandInset label
LatexCommand label
name "fig:constant-pointer-to-a-constant"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Focus on Software Engineering: Dynamic Memory Allocation
\end_layout

\begin_layout Standard
Dynamic memory allocation allows the creation of variables during the execution
 of a program.
 This is only possible through the use of pointers.
 When a variable is created on the fly, the program asks the computer to
 set aside enough memory to hold that variable and is given the starting
 address of that chunk of memory that the computer set aside for that newly
 created variable.
 That chunk of memory is only accessible through its address which is why
 pointers are a necessity.
\end_layout

\begin_layout Standard
To dynamically allocate memory, we use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 operator, as shown below.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

int *iptr = nullptr;
\end_layout

\begin_layout Plain Layout

iptr = new int;
\end_layout

\end_inset

The line with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 operator requests that the computer allocate enough memory to hold an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset

 and the pointer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iptr
\end_layout

\end_inset

 will hold the starting address of the allocated memory.
\end_layout

\begin_layout Standard
An very useful way to use dynamic memory allocation is with arrays of unknown
 size.
 An example of how to dynamically allocate memory for an array is given
 below.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

int *aptr = nullptr;
\end_layout

\begin_layout Plain Layout

aptr = new int[100];
\end_layout

\end_inset

Now, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iptr
\end_layout

\end_inset

 will hold the starting address of the allocated memory for an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset

 array with 100 elements.
 If the computer cannot allocate enough memory, then an exception will be
 thrown (Chapter 16).
\end_layout

\begin_layout Standard
When a program is finished with the allocated memory, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delete
\end_layout

\end_inset

 operator is used to free up any memory that was allocated using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

.
 If you don't free up allocated memory then your program will have a 
\emph on
memory leak
\emph default
.
 Also, only use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delete
\end_layout

\end_inset

 with pointers that were declared using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

.
 Otherwise, you're going to have some unexpected problems.
 Use of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delete
\end_layout

\end_inset

 operator is given below.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=none"
inline false
status open

\begin_layout Plain Layout

delete *iptr;
\end_layout

\begin_layout Plain Layout

delete [] aptr;
\end_layout

\begin_layout Plain Layout

// [] must be placed between delete and aptr for arrays
\end_layout

\end_inset


\end_layout

\end_body
\end_document
